#include "xoos/util/distance-functions.h"

#include <string>
#include <vector>

namespace xoos::distance {

template <typename T>
static T AbsoluteDifference(T a, T b) {
  return a > b ? a - b : b - a;
}

bool HammingDistanceThreshold(const std::string& source, const std::string& target, size_t distance) {
  size_t differences = AbsoluteDifference(source.length(), target.length());
  const size_t max_length = std::min(source.length(), target.length());
  for (size_t i = 0; i < max_length; i++) {
    if (source[i] != target[i]) {
      ++differences;
      if (differences > distance) {
        return false;
      }
    }
  }
  return differences <= distance;
}

// generated by GitHub CoPilot, then altered
bool LevenshteinDistanceThreshold(const std::string& source, const std::string& target, size_t distance) {
  using TSizeType = size_t;

  const TSizeType m = source.length();
  const TSizeType n = target.length();
  if (m == 0) {
    return n != 0u;
  }
  if (n == 0) {
    return m != 0u;
  }
  std::vector<std::vector<TSizeType>> matrix(m + 1);

  for (TSizeType i = 0; i <= m; ++i) {
    matrix[i].resize(n + 1);
    matrix[i][0] = i;
  }
  for (TSizeType i = 0; i <= n; ++i) {
    matrix[0][i] = i;
  }
  for (TSizeType i = 1; i <= m; ++i) {
    TSizeType min_cost = std::max(m, n);
    for (TSizeType j = 1; j <= n; ++j) {
      const int cost = (source[i - 1] == target[j - 1]) ? 0 : 1;
      matrix[i][j] = std::min(std::min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1), matrix[i - 1][j - 1] + cost);
      min_cost = std::min(min_cost, matrix[i][j]);
    }
    if (min_cost > distance) {
      return false;
    }
  }
  return matrix[m][n] <= distance;
}

bool IsUmiDistanceLeq(const std::string& source, const std::string& target, size_t distance) {
  // the distance is not defined when at least one of the UMIs
  // is empty - therefore, return false in this case
  if (source == "*" || target == "*") {
    return false;
  }
  return HammingDistanceThreshold(source, target, distance) || LevenshteinDistanceThreshold(source, target, distance);
}
}  // namespace xoos::distance
